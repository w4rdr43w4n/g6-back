from rest_framework.views import APIView
from rest_framework.generics import (
    CreateAPIView,
    GenericAPIView,
    ListCreateAPIView,
    RetrieveUpdateDestroyAPIView,
)
from rest_framework.response import Response
from rest_framework import status
from rest_framework.permissions import IsAuthenticated, AllowAny, IsAdminUser

from .models import ImprovementModel, CompletionModel, ArticlesModel
from .Utils.ai_utils import Wiki, GPT, AIUtils
from .pricing import Credit

from .serializers import (
    WikiSearchSerializer,
    ImprovementSerializer,
    CompletionSerializer,
    WikiPageSerializer,
    ArticlesSerializer,
    ArticlesUpdateSerializer,
)
from .search_utils import (
     search_in_arxiv,
     search_in_springer,
     search_in_libgen_pdf_books,
     get_citation

)
from .Utils import (
      ai_detection,
      plagiarism_detection
)
class Generatecitation(APIView):
    """
    params:
    type can be 'MLA' or 'APA' or 'Chicago' or 'Harvard' or 'Vancouver'
     title indicates paper title
    
    GET:  =>  api/v1/tools/generate-citation?title=[title]&type=[type]
    RES:  =>
     str (citation for the paper)
    
    """
    # permission_classes = [IsAuthenticated]
    permission_classes = [AllowAny]

    # api/v1/tools/wiki-search?title=quantum
    def get(self, request):
        # return Response(request.query_params)

        title = request.query_params.get("title")
        type = request.query_params.get("type")
        if (title):
            if(type):
                res = get_citation(title,type)
 
                return Response(res, status=status.HTTP_200_OK)
            return Response(
            {"missing parameter": "type"},
            status=status.HTTP_400_BAD_REQUEST,
        )
        return Response(
            {"missing parameter": "text"},
            status=status.HTTP_400_BAD_REQUEST,
        )
class Plagiarismdetection(APIView):
    """
    GET:  =>  api/v1/tools/plagiarism-detection?text=[text]
    RES:  =>
     Via webhook
    
    """
    #will be modifed with appropriate webhook handlers
    # permission_classes = [IsAuthenticated]
    permission_classes = [AllowAny]

    # api/v1/tools/wiki-search?title=quantum
    def get(self, request):
        # return Response(request.query_params)

        text = request.query_params.get("text")
        
        if text:
           res = plagiarism_detection(text)

           return Response(res, status=status.HTTP_200_OK)
        
        return Response(
            {"missing parameter": "text"},
            status=status.HTTP_400_BAD_REQUEST,
        )

class Aidetection(APIView):
    """
    GET:  =>  api/v1/tools/ai-detection?text=[text]
    RES:  =>
    {'Msg':"Generated By AI" or "Free of AI generated content",'Confidence probability':probapility,'isAI':True or False}
    
    """
    # permission_classes = [IsAuthenticated]
    permission_classes = [AllowAny]

    # api/v1/tools/wiki-search?title=quantum
    def get(self, request):
        # return Response(request.query_params)

        text = request.query_params.get("text")
        
        if text:
           res = ai_detection(text)

            return Response(res, status=status.HTTP_200_OK)
        
        return Response(
            {"missing parameter": "text"},
            status=status.HTTP_400_BAD_REQUEST,
        )
class ArxivSearchView(APIView):
    """
    GET:  =>  api/v1/tools/arxiv-search?title=[title]

        search for (title) in arxiv

        RES:  =>    [
                        {
                            "suggestion": "page",
                            "summary": "",
                            "url": "",
                        },
                        ...
                    ]
    """

    # permission_classes = [IsAuthenticated]
    permission_classes = [AllowAny]

    # api/v1/tools/wiki-search?title=quantum
    def get(self, request):
        # return Response(request.query_params)

        title = request.query_params.get("title")

        if title:
            res_list = []
            for result in search_in_arxiv(title):
                if result.pdf_url:
                    res_list.append(
                        {
                            "suggestion": result.title,
                            "summary": result.summary,
                            "url": result.pdf_url,
                        }
                    )

            return Response(res_list, status=status.HTTP_200_OK)

        return Response(
            {"missing parameter": "title"},
            status=status.HTTP_400_BAD_REQUEST,
        )


class SpringerSearchView(APIView):
    """
    GET:  =>  api/v1/tools/springer-search?title=[title]

        search for (title) in springer

        RES:  =>    [
                        {
                            "suggestion": "page",
                            "summary": "",
                            "url": "",
                        },
                        ...
                    ]
    """

    # permission_classes = [IsAuthenticated]
    permission_classes = [AllowAny]

    # api/v1/tools/wiki-search?title=quantum
    def get(self, request):
        # return Response(request.query_params)

        title = request.query_params.get("title")

        if title:
            res_list = []
            for result in search_in_springer(title):
                res_list.append(
                    {
                        "suggestion": result.title,
                        "summary": result.summary,
                        "url": result.page_url,
                    }
                )
                print(result.title)

            return Response(res_list, status=status.HTTP_200_OK)

        return Response(
            {"missing parameter": "title"},
            status=status.HTTP_400_BAD_REQUEST,
        )


class LibgenSearchView(APIView):
    """
    GET:  =>  api/v1/tools/libgen-search?title=[title]

        search for (title) in Libgen

        RES:  =>    [
                        {
                            "suggestion": "page",
                            "n_pages": "",
                            "size": "",
                            "year": "",
                            "url": "",
                        },
                        ...
                    ]
    """

    # permission_classes = [IsAuthenticated]
    permission_classes = [AllowAny]

    # api/v1/tools/wiki-search?title=quantum
    def get(self, request):
        # return Response(request.query_params)

        title = request.query_params.get("title")

        if title:
            res_list = []
            for result in search_in_libgen_pdf_books(title):
                res_list.append(
                    {
                        "suggestion": result.title,
                        "n_pages": result.pages,
                        "size": result.size,
                        "year": result.year,
                        "url": result.pdf_url,
                    }
                )
                print(result.title)

            return Response(res_list, status=status.HTTP_200_OK)

        return Response(
            {"missing parameter": "title"},
            status=status.HTTP_400_BAD_REQUEST,
        )


class ArticleRetrieveUpdateDestroyView(RetrieveUpdateDestroyAPIView):
    serializer_class = ArticlesUpdateSerializer
    permission_classes = (IsAuthenticated,)

    def get_queryset(self):
        return self.request.user.articles.all()

    def perform_create(self, serializer):
        serializer.save(user=self.request.user)


class ArticleListCreateView(ListCreateAPIView):
    serializer_class = ArticlesSerializer
    permission_classes = (IsAuthenticated,)

    def get_queryset(self):
        return self.request.user.articles.all()

    def perform_create(self, serializer):
        serializer.save(user=self.request.user)


class GetLangsView(APIView):
    """
    GET:

        Retrieve all allowed languages for wiki

        RES =>
                {
                    "langKey" : "langName",
                    "en"      : "English",
                    "ar"      : "العربية",
                    ...
                }

    """

    permission_classes = [AllowAny]

    def get(self, request):
        # print("||||||||||| " + str(request))
        return Response(Wiki.get_langs())


class WikiSearchView(APIView):
    """
    GET:  =>  api/v1/tools/wiki-search?title=[title]&n=[n of suggestions]&lang=[langKey]

        search for (title) in wikipages and return (n) suggestions


        RES:  =>    [
                        "page1",
                        "page2",
                        "page3",
                        ...
                    ]


        RES:  =>    [
                        {
                            "suggestion": "page",
                            "disambiguation": True,
                            "summary": ""|["pag1","page2",...],
                        },
                        ...
                    ]


    """

    permission_classes = [AllowAny]

    # api/v1/tools/wiki-search?title=missingno&n=20&lang=en
    def get(self, request):
        # return Response(request.query_params)
        serializer = WikiSearchSerializer(data=request.query_params)
        serializer.is_valid(raise_exception=True)
        validated_data = serializer.data
        title = validated_data.get("title")
        n = validated_data.get("n")
        lang = validated_data.get("lang")

        if title:
            return Response(
                Wiki.search(title=title, n_suggestions=int(n),
                            lang=lang, summary=True)
            )

        return Response(
            {"missing parameter": "title"},
            status=status.HTTP_400_BAD_REQUEST,
        )


class WikiSummaryView(APIView):
    """
    GET:  =>  api/v1/tools/wiki-summary?page_id=[page title]

        return string of a summary for the page with this title(page_id)

        RES => "summary for that article is ..."


    """

    permission_classes = [AllowAny]

    def get(self, request):
        page_id = request.query_params.get("page_id")

        try:
            if page_id:
                return Response(
                    Wiki.summary(page_id=page_id), status=status.HTTP_200_OK
                )
            else:
                return Response(
                    {"missing parameter": " page_id"},
                    status=status.HTTP_400_BAD_REQUEST,
                )
        except Exception as e:
            return Response(str(e), status=status.HTTP_400_BAD_REQUEST)


class WikiPageView(GenericAPIView):
    """
    POST :

        return all page that has page_id (as a page title)

        RES =>
                [
                    {
                        "title"  : "page title (page_id)" / "section title"
                        "type"   :  "page_title" / "heading_1"/ "heading_2"/ "heading_3" /..
                        "content":  "..."
                    },
                    ...
                ]
    """

    permission_classes = [AllowAny]
    serializer_class = WikiPageSerializer

    def get_queryset(self):
        return ""

    def post(self, request):
        serializer = WikiPageSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        validated_data = serializer.data
        page_id = validated_data.get("page_id")
        lang = validated_data.get("lang")
        page = Wiki.page(title=page_id, lang=lang, permitted_chars=10_000)
        try:
            return Response(page, status=status.HTTP_200_OK)
        except Exception as e:
            return Response(e, status=status.HTTP_400_BAD_REQUEST)


class ImprovementView(CreateAPIView):
    """
    return text after improving it
    """

    serializer_class = ImprovementSerializer
    queryset = ImprovementModel.objects.all()

    def create(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        validated_data = serializer.validated_data
        text = validated_data.get("text")
        lang = AIUtils.detect_lang(text=text)
        messages = GPT.improvement_messages(
            text=text,
            lang=lang,
        )
        res = GPT.improvement(
            messages=messages["messages"],
            n=1,
            stream=False,
        )
        improved_text = GPT.response_message(res)[0]
        used_credits = Credit.calc(
            operation=Credit.Operation.improvement,
            n_tokens=res["usage"]["completion_tokens"]
        )
        total_tokens = res["usage"]["total_tokens"]
        serializer.save(improved_text=improved_text)

        headers = self.get_success_headers(serializer.data)
        return Response(improved_text, status=status.HTTP_201_CREATED, headers=headers)


class SentenceCompletionView(CreateAPIView):
    serializer_class = CompletionSerializer
    queryset = CompletionModel.objects.all()

    def create(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        validated_data = serializer.validated_data
        feed = GPT.completion_feed_from_text(validated_data.get("feed"))
        res = GPT.paragraph_completion(
            prompt=feed,
            title=validated_data.get("title"),
            sentence=False,
            stream=False,
        )
        completion = GPT.response_message(res)[0]
        used_credits = Credit.calc(
            operation=Credit.Operation.completion,
            n_tokens=res["usage"]["completion_tokens"]
        )
        total_tokens = res["usage"]["total_tokens"]
        serializer.save(completion=completion)
        headers = self.get_success_headers(serializer.data)
        return Response(completion, status=status.HTTP_201_CREATED, headers=headers)
